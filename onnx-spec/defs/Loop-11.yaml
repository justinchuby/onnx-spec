attributes:
- default_value: null
  description: 'The graph run each iteration. It has 2+N inputs: (iteration_num, condition,
    loop carried dependencies...). It has 1+N+K outputs: (condition, loop carried
    dependencies..., scan_outputs...). Each scan_output is created by concatenating
    the value of the specified output value at the end of each iteration of the loop.
    It is an error if the dimensions or data type of these scan_outputs change across
    loop iterations.'
  name: body
  required: true
  type: AttrType.GRAPH
deprecated: false
doc: "\nGeneric Looping construct. This loop has multiple termination conditions:\n\
  \n1) Trip count. Iteration count specified at runtime. Set by\n   specifying the\
  \ input M. Optional. Set to empty string to omit.\n   Note that a static trip count\
  \ (specified at graph construction time) can be\n   specified by passing in a constant\
  \ node for input M.\n2) Loop termination condition. This is an input to the op that\
  \ determines\n   whether to run the first iteration and also a loop-carried dependency\
  \ for\n   the body graph. The body graph must yield a value for the condition variable,\n\
  \   whether this input is provided or not.\n\nThis table summarizes the operating\
  \ modes of this operator with equivalent\nC-style code:\n\n    Operator inputs defined\
  \ as (max_trip_count, condition_var).\n\n    input (\"\", \"\"):\n        for (int\
  \ i=0; ; ++i) {\n          cond = ... // Note this value is ignored, but is required\
  \ in the body\n        }\n\n    input (\"\", cond) // Note this is analogous to\
  \ a while loop\n        bool cond = ...;\n        for (int i=0; cond; ++i) {\n \
  \         cond = ...;\n        }\n\n    input (\"\", 1) // Note this is analogous\
  \ to a do-while loop\n        bool cond = true\n        for (int i=0; cond; ++i)\
  \ {\n          cond = ...;\n        }\n\n    input (trip_count, \"\") // Note this\
  \ is analogous to a for loop\n        int trip_count = ...\n        for (int i=0;\
  \ i < trip_count; ++i) {\n          cond = ...; // ignored\n        }\n\n    input\
  \ (trip_count, cond)\n        int trip_count = ...;\n        bool cond = ...;\n\
  \        for (int i=0; i < trip_count && cond; ++i) {\n          cond = ...;\n \
  \       }\n\n\n*Sample usage - cond as well as trip count*\n\n    graph predict-net\
  \ {\n      %a = Constant[value = <Scalar Tensor [3]>]()\n      %b = Constant[value\
  \ = <Scalar Tensor [6]>]()\n      %keepgoing = Constant[value = <Scalar Tensor [1]>]()\n\
  \      %max_trip_count = Constant[value = <Scalar Tensor [10]>]()\n      %keepgoing_out,\
  \ %b_out, %user_defined_vals = Loop[body = <graph body-net>](%max_trip_count, %keepgoing,\
  \ %b)\n      return\n    }\n\n    graph body-net (\n      %i[INT32, scalar]    \
  \       // iteration number\n      %keepgoing_in[BOOL, scalar] // incoming loop-termination-condition;\
  \ not used\n      %b_in[INT32, scalar]        // incoming value of loop-carried-dependency\
  \ b\n    ) {\n      %my_local = Add(%a, %b_in)\n      %b_out = Sub(%a, %b_in) //\
  \ outgoing value of loop-carried-dependency b\n      %keepgoing_out = Greater(%my_local,\
  \ %b_out) // outgoing loop-termination-condition\n      %user_defined_val = Add(%b_in,\
  \ %b_in) // scan-output value to be accumulated\n      return %keepgoing_out, %b_out,\
  \ %user_defined_val\n    }\n\n*Sample equivalent C code*\n\n    {\n      /* User-defined\
  \ code (enclosing scope) */\n      int a = 3, b = 6;\n      bool keepgoing = true;\
  \ // Analogous to input cond\n      /* End user-defined code */\n\n      /* Implicitly-defined\
  \ code */\n      const int max_trip_count = 10; // Analogous to input M\n      int\
  \ user_defined_vals[]; // Imagine this is resizable\n      /* End implicitly-defined\
  \ code */\n      /* initialize loop-carried variables and scan-output variables\
  \ */\n      bool keepgoing_out = keepgoing\n      int b_out = b\n\n      for (int\
  \ i=0; i < max_trip_count && keepgoing_out; ++i) {\n        /* Implicitly-defined\
  \ code: bind actual parameter values\n           to formal parameter variables of\
  \ loop-body */\n        bool keepgoing_in = keepgoing_out;\n        bool b_in =\
  \ b_out;\n\n        /* User-defined code (loop body) */\n        int my_local =\
  \ a + b_in; // Reading value \"a\" from the enclosing scope is fine\n        b_out\
  \ = a - b_in;\n        keepgoing_out = my_local > b_out;\n        user_defined_val\
  \ = b_in + b_in; // b_in and b_out are different variables\n        /* End user-defined\
  \ code */\n\n        /* Implicitly defined-code */\n        user_defined_vals[i]\
  \ = user_defined_val // accumulate scan-output values\n      }\n      // int t =\
  \ my_local; // Can't do this. my_local is not accessible here.\n\n      // The values\
  \ below are bound to the output variables of the loop and therefore accessible\n\
  \      // b_out; user_defined_vals; keepgoing_out;\n    }\n\nThere are several things\
  \ of note in this code snippet:\n\n1) Values from the enclosing scope (i.e. variable\
  \ \"a\" here) are in scope and can\n   be referenced in the inputs of the loop.\n\
  2) Any values computed in the loop body that needs to be used in a subsequent\n\
  \   iteration or after the loop are modelled using a pair of variables in the loop-body,\n\
  \   consisting of an input variable (eg., b_in) and an output variable (eg., b_out).\n\
  \   These are referred to as loop-carried dependences. The loop operation node\n\
  \   supplies the input value of the input variable for the first iteration, and\n\
  \   returns the output value of the output variable produced by the final\n   iteration.\n\
  3) Scan_output variables are used to implicitly concatenate values computed across\n\
  \   all the iterations. In the above example, the value of user_defined_val computed\n\
  \   over all iterations are concatenated and returned as the value of user_defined_vals\n\
  \   after the loop.\n4) Values created in the body cannot be accessed in the enclosing\
  \ scope,\n   except using the mechanism described above.\n\nNote that the semantics\
  \ of this op support \"diagonal\" or \"wavefront\" execution.\n(See Step 3 here\
  \ for an example:\nhttps://devblogs.nvidia.com/optimizing-recurrent-neural-networks-cudnn-5/).\n\
  Frontends should emit multi-layer RNNs as a series of While operators (with\ntime\
  \ being the inner looping dimension), with each successive layer consuming\nthe\
  \ scan_outputs from the previous layer, possibly going through several\npoint-wise\
  \ operators (e.g. dropout, residual connections, linear layer).\n"
domain: ''
inputs:
- description: A maximum trip-count for the loop specified at runtime. Optional. Pass
    empty string to skip.
  min_arity: 1
  name: M
  tags:
  - optional
  type_str: I
- description: A boolean termination condition. Optional. Pass empty string to skip.
  min_arity: 1
  name: cond
  tags:
  - optional
  type_str: B
- description: The initial values of any loop-carried dependencies (values that change
    across loop iterations)
  min_arity: 0
  name: v_initial
  tags:
  - variadic
  - heterogeneous
  type_str: V
max_input: 2147483647
max_output: 2147483647
min_input: 2
min_output: 1
name: Loop
outputs:
- description: Final N loop carried dependency values then K scan_outputs
  min_arity: 1
  name: v_final_and_scan_outputs
  tags:
  - variadic
  - heterogeneous
  type_str: V
since_version: 11
support_level: SupportType.COMMON
type_constraints:
- allowed_type_strs:
  - tensor(uint8)
  - tensor(uint16)
  - tensor(uint32)
  - tensor(uint64)
  - tensor(int8)
  - tensor(int16)
  - tensor(int32)
  - tensor(int64)
  - tensor(float16)
  - tensor(float)
  - tensor(double)
  - tensor(string)
  - tensor(bool)
  - tensor(complex64)
  - tensor(complex128)
  description: All Tensor types
  type_param_str: V
- allowed_type_strs:
  - tensor(int64)
  description: tensor of int64, which should be a scalar.
  type_param_str: I
- allowed_type_strs:
  - tensor(bool)
  description: tensor of bool, which should be a scalar.
  type_param_str: B
