domain: ''
name: ScatterND
since_version: 18
min_input: 3
max_input: 3
min_output: 1
max_output: 1
doc: "\nScatterND takes three inputs `data` tensor of rank r >= 1, `indices` tensor\
  \ of rank q >= 1,\nand `updates` tensor of rank q + r - indices.shape[-1] - 1. The\
  \ output of the operation\nis produced by creating a copy of the input `data`, and\
  \ then updating its value to values\nspecified by `updates` at specific index positions\
  \ specified by `indices`. Its output shape\nis the same as the shape of `data`.\n\
  \n`indices` is an integer tensor. Let k denote indices.shape[-1], the last dimension\
  \ in the shape of `indices`.\n`indices` is treated as a (q-1)-dimensional tensor\
  \ of k-tuples, where each k-tuple is a partial-index into `data`.\nHence, k can\
  \ be a value at most the rank of `data`. When k equals rank(data), each update entry\
  \ specifies an\nupdate to a single element of the tensor. When k is less than rank(data)\
  \ each update entry specifies an\nupdate to a slice of the tensor. Index values\
  \ are allowed to be negative, as per the usual\nconvention for counting backwards\
  \ from the end, but are expected in the valid range.\n\n`updates` is treated as\
  \ a (q-1)-dimensional tensor of replacement-slice-values. Thus, the\nfirst (q-1)\
  \ dimensions of updates.shape must match the first (q-1) dimensions of indices.shape.\n\
  The remaining dimensions of `updates` correspond to the dimensions of the\nreplacement-slice-values.\
  \ Each replacement-slice-value is a (r-k) dimensional tensor,\ncorresponding to\
  \ the trailing (r-k) dimensions of `data`.  Thus, the shape of `updates`\nmust equal\
  \ indices.shape[0:q-1] ++ data.shape[k:r-1], where ++ denotes the concatenation\n\
  of shapes.\n\nThe `output` is calculated via the following equation:\n\n```\noutput\
  \ = np.copy(data)\nupdate_indices = indices.shape[:-1]\nfor idx in np.ndindex(update_indices):\n\
  \    output[indices[idx]] = updates[idx]\n```\n\nThe order of iteration in the above\
  \ loop is not specified.\nIn particular, indices should not have duplicate entries:\
  \ that is, if idx1 != idx2, then indices[idx1] != indices[idx2].\nThis ensures that\
  \ the output value does not depend on the iteration order.\n\n`reduction` allows\
  \ specification of an optional reduction operation, which is applied to all values\
  \ in `updates`\ntensor into `output` at the specified `indices`.\nIn cases where\
  \ `reduction` is set to \"none\", indices should not have duplicate entries: that\
  \ is, if idx1 != idx2,\nthen indices[idx1] != indices[idx2]. This ensures that the\
  \ output value does not depend on the iteration order.\nWhen `reduction` is set\
  \ to some reduction function `f`, `output` is calculated as follows:\n\n```\noutput\
  \ = np.copy(data)\nupdate_indices = indices.shape[:-1]\nfor idx in np.ndindex(update_indices):\n\
  \    output[indices[idx]] = f(output[indices[idx]], updates[idx])\n```\n\nwhere\
  \ the `f` is `+`, `*`, `max` or `min` as specified.\n\nThis operator is the inverse\
  \ of GatherND.\n\n(Opset 18 change): Adds max/min to the set of allowed reduction\
  \ ops.\n\nExample 1:\n```\ndata    = [1, 2, 3, 4, 5, 6, 7, 8]\nindices = [[4], [3],\
  \ [1], [7]]\nupdates = [9, 10, 11, 12]\noutput  = [1, 11, 3, 10, 9, 6, 7, 12]\n\
  ```\n\nExample 2:\n```\ndata    = [[[1, 2, 3, 4], [5, 6, 7, 8], [8, 7, 6, 5], [4,\
  \ 3, 2, 1]],\n            [[1, 2, 3, 4], [5, 6, 7, 8], [8, 7, 6, 5], [4, 3, 2, 1]],\n\
  \            [[8, 7, 6, 5], [4, 3, 2, 1], [1, 2, 3, 4], [5, 6, 7, 8]],\n       \
  \     [[8, 7, 6, 5], [4, 3, 2, 1], [1, 2, 3, 4], [5, 6, 7, 8]]]\nindices = [[0],\
  \ [2]]\nupdates = [[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],\n \
  \           [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]]]\noutput  =\
  \ [[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],\n            [[1, 2,\
  \ 3, 4], [5, 6, 7, 8], [8, 7, 6, 5], [4, 3, 2, 1]],\n            [[1, 1, 1, 1],\
  \ [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]],\n            [[8, 7, 6, 5], [4, 3,\
  \ 2, 1], [1, 2, 3, 4], [5, 6, 7, 8]]]\n```\n"
attributes:
- name: reduction
  description: 'Type of reduction to apply: none (default), add, mul, max, min. ''none'':
    no reduction applied. ''add'':  reduction using the addition operation. ''mul'':  reduction
    using the addition operation. ''max'': reduction using the maximum operation.''min'':
    reduction using the minimum operation.'
  type: AttrType.STRING
  required: false
  default_value: none
inputs:
- name: data
  type_str: T
  description: Tensor of rank r >= 1.
  min_arity: 1
  tags:
  - differentiable
- name: indices
  type_str: tensor(int64)
  description: Tensor of rank q >= 1.
  min_arity: 1
  tags:
  - non-differentiable
- name: updates
  type_str: T
  description: Tensor of rank q + r - indices_shape[-1] - 1.
  min_arity: 1
  tags:
  - differentiable
outputs:
- name: output
  type_str: T
  description: Tensor of rank r >= 1.
  min_arity: 1
  tags:
  - differentiable
type_constraints:
- type_param_str: T
  description: Constrain input and output types to any tensor type.
  allowed_type_strs:
  - tensor(uint8)
  - tensor(uint16)
  - tensor(uint32)
  - tensor(uint64)
  - tensor(int8)
  - tensor(int16)
  - tensor(int32)
  - tensor(int64)
  - tensor(bfloat16)
  - tensor(float16)
  - tensor(float)
  - tensor(double)
  - tensor(string)
  - tensor(bool)
  - tensor(complex64)
  - tensor(complex128)
support_level: COMMON
deprecated: false
