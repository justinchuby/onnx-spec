domain: ''
name: GatherND
since_version: 13
min_input: 2
max_input: 2
min_output: 1
max_output: 1
doc: "\nGiven `data` tensor of rank `r` >= 1, `indices` tensor of rank `q` >= 1, and\
  \ `batch_dims` integer `b`, this operator gathers\nslices of `data` into an output\
  \ tensor of rank `q + r - indices_shape[-1] - 1 - b`.\n\n`indices` is an q-dimensional\
  \ integer tensor, best thought of as a `(q-1)`-dimensional tensor of index-tuples\
  \ into `data`,\nwhere each element defines a slice of `data`\n\n`batch_dims` (denoted\
  \ as `b`) is an integer indicating the number of batch dimensions, i.e the leading\
  \ `b` number of dimensions of\n`data` tensor and `indices` are representing the\
  \ batches, and the gather starts from the `b+1` dimension.\n\nSome salient points\
  \ about the inputs' rank and shape:\n\n1) r >= 1 and q >= 1 are to be honored. There\
  \ is no dependency condition to be met between ranks `r` and `q`\n\n2) The first\
  \ `b` dimensions of the shape of `indices` tensor and `data` tensor must be equal.\n\
  \n3) b < min(q, r) is to be honored.\n\n4) The `indices_shape[-1]` should have a\
  \ value between 1 (inclusive) and rank `r-b` (inclusive)\n\n5) All values in `indices`\
  \ are expected to be within bounds [-s, s-1] along axis of size `s` (i.e.) `-data_shape[i]\
  \ <= indices[...,i] <= data_shape[i] - 1`.\n   It is an error if any of the index\
  \ values are out of bounds.\n\nThe output is computed as follows:\n\nThe output\
  \ tensor is obtained by mapping each index-tuple in the `indices` tensor to the\
  \ corresponding slice of the input `data`.\n\n1) If `indices_shape[-1] > r-b` =>\
  \ error condition\n\n2) If `indices_shape[-1] == r-b`, since the rank of `indices`\
  \ is `q`, `indices` can be thought of as `N` `(q-b-1)`-dimensional tensors\n   containing\
  \ 1-D tensors of dimension `r-b`, where `N` is an integer equals to the product\
  \ of 1 and all the elements in the batch dimensions\n   of the indices_shape. Let\
  \ us think of each such `r-b` ranked tensor as `indices_slice`. Each *scalar value*\
  \ corresponding to `data[0:b-1,indices_slice]`\n   is filled into the corresponding\
  \ location of the `(q-b-1)`-dimensional tensor to form the `output` tensor (Example\
  \ 1 below)\n\n3) If `indices_shape[-1] < r-b`, since the rank of `indices` is `q`,\
  \ `indices` can be thought of as `N` `(q-b-1)`-dimensional tensor\n   containing\
  \ 1-D tensors of dimension `< r-b`. Let us think of each such tensors as `indices_slice`.\
  \ Each *tensor slice* corresponding\n   to `data[0:b-1, indices_slice , :]` is filled\
  \ into the corresponding location of the `(q-b-1)`-dimensional tensor\n   to form\
  \ the `output` tensor (Examples 2, 3, 4 and 5 below)\n\nThis operator is the inverse\
  \ of `ScatterND`.\n\n**Example 1**\n\n```\nbatch_dims = 0\ndata    = [[0,1],[2,3]]\
  \   # data_shape    = [2, 2]\nindices = [[0,0],[1,1]]   # indices_shape = [2, 2]\n\
  output  = [0,3]           # output_shape  = [2]\n```\n\n**Example 2**\n\n```\nbatch_dims\
  \ = 0\ndata    = [[0,1],[2,3]]  # data_shape    = [2, 2]\nindices = [[1],[0]]  \
  \    # indices_shape = [2, 1]\noutput  = [[2,3],[0,1]]  # output_shape  = [2, 2]\n\
  ```\n\n**Example 3**\n\n```\nbatch_dims = 0\ndata    = [[[0,1],[2,3]],[[4,5],[6,7]]]\
  \ # data_shape    = [2, 2, 2]\nindices = [[0,1],[1,0]]                 # indices_shape\
  \ = [2, 2]\noutput  = [[2,3],[4,5]]                 # output_shape  = [2, 2]\n```\n\
  \n**Example 4**\n\n```\nbatch_dims = 0\ndata    = [[[0,1],[2,3]],[[4,5],[6,7]]]\
  \ # data_shape    = [2, 2, 2]\nindices = [[[0,1]],[[1,0]]]             # indices_shape\
  \ = [2, 1, 2]\noutput  = [[[2,3]],[[4,5]]]             # output_shape  = [2, 1,\
  \ 2]\n```\n\n**Example 5**\n\n```\nbatch_dims = 1\ndata    = [[[0,1],[2,3]],[[4,5],[6,7]]]\
  \ # data_shape    = [2, 2, 2]\nindices = [[1],[0]]                     # indices_shape\
  \ = [2, 1]\noutput  = [[2,3],[4,5]]                 # output_shape  = [2, 2]\n```\n"
attributes:
- name: batch_dims
  description: The number of batch dimensions. The gather of indexing starts from
    dimension of data[batch_dims:]
  type: AttrType.INT
  required: false
  default_value: 0
inputs:
- name: data
  type_str: T
  description: Tensor of rank r >= 1.
  min_arity: 1
  tags:
  - differentiable
- name: indices
  type_str: tensor(int64)
  description: Tensor of rank q >= 1. All index values are expected to be within bounds
    [-s, s-1] along axis of size s. It is an error if any of the index values are
    out of bounds.
  min_arity: 1
  tags:
  - non-differentiable
outputs:
- name: output
  type_str: T
  description: Tensor of rank q + r - indices_shape[-1] - 1.
  min_arity: 1
  tags:
  - differentiable
type_constraints:
- type_param_str: T
  description: Constrain input and output types to any tensor type.
  allowed_type_strs:
  - tensor(uint8)
  - tensor(uint16)
  - tensor(uint32)
  - tensor(uint64)
  - tensor(int8)
  - tensor(int16)
  - tensor(int32)
  - tensor(int64)
  - tensor(bfloat16)
  - tensor(float16)
  - tensor(float)
  - tensor(double)
  - tensor(string)
  - tensor(bool)
  - tensor(complex64)
  - tensor(complex128)
support_level: COMMON
deprecated: false
