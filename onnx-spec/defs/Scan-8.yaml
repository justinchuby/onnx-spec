domain: ''
name: Scan
since_version: 8
min_input: 2
max_input: 2147483647
min_output: 1
max_output: 2147483647
doc: "\nScan can be used to iterate over one or more scan_input tensors,\nconstructing\
  \ zero or more scan_output tensors. It combines ideas from general recurrences,\n\
  functional programming constructs such as scan, fold, map, and zip, and is intended\
  \ to enable\ngeneralizations of RNN-like constructs for sequence-to-sequence processing.\n\
  Other tensors (referred to as state_variables here) can be used to carry a state\n\
  when iterating from one element to another (similar to hidden-state in RNNs, also\
  \ referred\nto as loop-carried dependences in the context of loops). All these tensors\
  \ are required to\nhave the same shape in each iteration of the loop (a restriction\
  \ imposed to enable efficient\nmemory allocation). Many common usages involve a\
  \ single scan_input tensor (where functionality\nsimilar to scan, fold and map can\
  \ be obtained). When more than one scan_input is used,\na behavior similar to zip\
  \ is obtained.\n\nThe attribute body must be a graph, specifying the computation\
  \ to be performed in\nevery iteration. It takes as input the current values of the\
  \ state_variables and\nthe current iterated element of the scan_inputs. It must\
  \ return the (updated) values\nof the state_variables and zero or more scan_output_element\
  \ tensors. The values of the\nscan_output_element tensors are concatenated over\
  \ all the iterations to produce the\nscan_output values of the scan construct (similar\
  \ to the concatenated intermediate\nhidden-state values of RNN-like constructs).\n\
  \nThe scan operation returns the final values of the state_variables as well as\
  \ the\nscan_outputs.\n\nThe operation supports batching, and the batch-axis is required\
  \ to be 0.\nWhen multiple scan_input tensors are used, they must all have the same\
  \ batch-size,\nand they must all have the same maximum-sequence-length (the dimensionality\
  \ of the\nsequence axis or scan axis). The sequence axis or scan axis is required\
  \ to be 1.\n\nThe operation has an optional sequence_lens input (of shape [BATCH_SIZE])\
  \ to\nallow variable length sequences of length <= the maximum-sequence-length.\
  \ If this\ninput is not specified, all sequences are assumed to be of length equal\
  \ to\nmaximum-sequence-length. For variable length input sequences, the scan_outputs\n\
  will consist of a sequence of same length as the input, padded to the\nmaximum-sequence-length.\n\
  \nThe optional attribute directions can be used to scan a sequence in the reverse\
  \ direction.\nIf this attribute is omitted, all sequences are scanned in the forward\
  \ direction.\nA bidirectional scan be performed by specifying the same tensor input\
  \ twice in the\nscan_inputs, once with a forward direction, and once with a backward\
  \ direction.\n\nNote that because of the ONNX restriction that only the last parameter\
  \ of an operator can\nbe variadic, the initial-states and scan-inputs are listed\
  \ together as one input parameter.\nSimilarly, the final-states and scan-outputs\
  \ are listed together as one output parameter.\nThe attribute num_scan_inputs indicates\
  \ the number M of scan-inputs.\n\nThe behavior of\n\n    Scan <\n        num_scan_inputs\
  \ = m,\n        body = loop-body\n    > (sequence_lengths, init_1, ..., init_n,\
  \ scan_1, ..., scan_m)\n\nis equivalent to the following pseudo-code:\n\n    //\
  \ T.shape[0] denotes the batch-size of T\n    // The batch-size of scan_1, ...,\
  \ scan_m are all required to be equal\n    batch_size = scan_1.shape[0];\n\n   \
  \ // scan_i.shape[1] denotes the (max) sequence-length of scan_i\n    // scan_i.shape[1]\
  \ is required to be equal to scan_j.shape[1] for all i,j.\n    max_sequence_length\
  \ = scan_1.shape[1];\n\n    for (int batch = 0; batch < batch_size; ++batch) {\n\
  \        // initialize state-variables\n        st_1 = init_1; ... st_n = init_n;\n\
  \        // initialize scan-output variables: [] denotes an empty tensor\n     \
  \   scan_out_1 = []; ...; scan_out_k = [];\n        // identify number of iterations:\n\
  \        N = (sequence_lengths specified) ? sequence_lengths[batch] : max_sequence_length;\n\
  \n        // execute loop\n        for (int t = 0; t < N; ++t) {\n            //\
  \ generate the scan-input elements: the notation T<axis=k>[t] indicates the sub-tensor\n\
  \            // of rank one less than T obtained by indexing T at position t along\
  \ axis k.\n            si_1 = (scan_1<axis=0>[batch])<axis=1>[t];\n            ...\
  \ ;\n            si_m = (scan_m<axis=0>[batch])<axis=1>[t];\n            // execute\
  \ loop-body\n            st_1, ..., st_n, so_1, ..., so_k = loop-body(st_1, ...,\
  \ st_n, si_1, ..., si_m)\n            // accumulate the scan-output elements\n \
  \           scan_out_1 = Concat<axis=0>(scan_out_1, so_1); ... ; scan_out_k = Concat<axis=0>(scan_out_k,\
  \ so_k);\n        }\n        // accumulate the outputs for this batch:\n       \
  \ bst_1[batch] = st_1; ..., bst_n[batch] = st_n;\n        // Note scan-outputs will\
  \ have size max_sequence_length, but only first N values will be meaningful.\n \
  \       // The remaining values have an undefined value.\n        b_scan_out_1[batch]\
  \ = scan_out_1; ...; b_scan_out_k[batch] = scan_out_k;\n    }\n    return bst_1,\
  \ ..., bst_n, b_scan_out_1, ..., b_scan_out_k;\n\n\n\n*Sample usage: Encoding RNN\
  \ using a Scan*\n\nThe following example shows how a simple RNN over an input tensor\
  \ %X, with weight tensor %Wi,\nrecurrence weight tensor %Ri, bias tensors %Wbi and\
  \ %Rbi, and initial hidden-state %H_0 can\nbe encoded as a ScanLoop. Note that the\
  \ loop-body is a nested graph, and it directly computes\n%Wi, %Ri, %Wbi, and %Rbi\
  \ (typically constants or initializers in the body graph). If these\nvalues are\
  \ computed in the outer graph, they need to be passed in as extra state_variables.\n\
  \n    graph rnn-encoding {\n      %H_0 = ...\n      %X = ...\n      %Y_h, %Y = Scan[body\
  \ = <graph rnn-cell-1>, num_scan_inputs=1](\"\", %H_0, %X)\n      return %Y, %Y_h\n\
  \    }\n\n    graph rnn-cell-1 (\n      %H_tminus1[FLOAT, tensor]\n      %X_t[FLOAT,\
  \ tensor]\n    ) {\n      %Wi = ...\n      %Ri = ...\n      %Wbi = ...\n      %Rbi\
  \ = ...\n      %t1 = X_t * (Wi^T)\n      %t2 = H_tminus1*(Ri^T)\n      %t3 = Add(%t1,\
  \ %t2)\n      %t4 = Add(%t3, %Wbi)\n      %t5 = Add(%t4, %Rbi)\n      %Ht = Tanh(%t5)\n\
  \      %Accumulate = Identity(%Ht)\n      return %Ht, %Accumulate\n    }\n\n"
attributes:
- name: body
  description: 'The graph run each iteration. It has N+M inputs: (loop state variables...,
    scan_input_elts...). It has N+K outputs: (loop state variables..., scan_output_elts...).
    Each scan_output is created by concatenating the value of the specified scan_output_elt
    value at the end of each iteration of the loop. It is an error if the dimensions
    of these values change across loop iterations.'
  type: AttrType.GRAPH
  required: true
  default_value: null
- name: directions
  description: 'An optional list of M flags. The i-th element of the list specifies
    the direction to be scanned for the i-th scan_input tensor: 0 indicates forward
    direction and 1 indicates reverse direction. If omitted, all scan_input tensors
    will be scanned in the forward direction.'
  type: AttrType.INTS
  required: false
  default_value: null
- name: num_scan_inputs
  description: 'An attribute specifying the number of scan_inputs M. '
  type: AttrType.INT
  required: true
  default_value: null
inputs:
- name: sequence_lens
  type_str: I
  description: Optional tensor specifying lengths of the sequences in a batch. If
    this input is not specified, all sequences are assumed to be of the maximum sequence
    length (the dimension of the sequence axis of the scan_input tensors).
  min_arity: 1
  tags:
  - optional
- name: initial_state_and_scan_inputs
  type_str: V
  description: Initial values of the loop's N state variables followed by M scan_inputs
  min_arity: 1
  tags:
  - variadic
  - heterogeneous
outputs:
- name: final_state_and_scan_outputs
  type_str: V
  description: Final values of the loop's N state variables followed by K scan_outputs
  min_arity: 1
  tags:
  - variadic
  - heterogeneous
type_constraints:
- type_param_str: I
  description: Int64 tensor
  allowed_type_strs:
  - tensor(int64)
- type_param_str: V
  description: All Tensor types
  allowed_type_strs:
  - tensor(uint8)
  - tensor(uint16)
  - tensor(uint32)
  - tensor(uint64)
  - tensor(int8)
  - tensor(int16)
  - tensor(int32)
  - tensor(int64)
  - tensor(float16)
  - tensor(float)
  - tensor(double)
  - tensor(string)
  - tensor(bool)
  - tensor(complex64)
  - tensor(complex128)
support_level: COMMON
deprecated: false
