domain: ''
name: ScatterND
since_version: 18
min_input: 3
max_input: 3
min_output: 1
max_output: 1
doc: |-
  ScatterND takes three inputs `data` tensor of rank r >= 1, `indices` tensor of rank q >= 1,
  and `updates` tensor of rank q + r - indices.shape[-1] - 1. The output of the operation
  is produced by creating a copy of the input `data`, and then updating its value to values
  specified by `updates` at specific index positions specified by `indices`. Its output shape
  is the same as the shape of `data`.

  `indices` is an integer tensor. Let k denote indices.shape[-1], the last dimension in the shape of `indices`.
  `indices` is treated as a (q-1)-dimensional tensor of k-tuples, where each k-tuple is a partial-index into `data`.
  Hence, k can be a value at most the rank of `data`. When k equals rank(data), each update entry specifies an
  update to a single element of the tensor. When k is less than rank(data) each update entry specifies an
  update to a slice of the tensor. Index values are allowed to be negative, as per the usual
  convention for counting backwards from the end, but are expected in the valid range.

  `updates` is treated as a (q-1)-dimensional tensor of replacement-slice-values. Thus, the
  first (q-1) dimensions of updates.shape must match the first (q-1) dimensions of indices.shape.
  The remaining dimensions of `updates` correspond to the dimensions of the
  replacement-slice-values. Each replacement-slice-value is a (r-k) dimensional tensor,
  corresponding to the trailing (r-k) dimensions of `data`.  Thus, the shape of `updates`
  must equal indices.shape[0:q-1] ++ data.shape[k:r-1], where ++ denotes the concatenation
  of shapes.

  The `output` is calculated via the following equation:

  ```
  output = np.copy(data)
  update_indices = indices.shape[:-1]
  for idx in np.ndindex(update_indices):
      output[indices[idx]] = updates[idx]
  ```

  The order of iteration in the above loop is not specified.
  In particular, indices should not have duplicate entries: that is, if idx1 != idx2, then indices[idx1] != indices[idx2].
  This ensures that the output value does not depend on the iteration order.

  `reduction` allows specification of an optional reduction operation, which is applied to all values in `updates`
  tensor into `output` at the specified `indices`.
  In cases where `reduction` is set to "none", indices should not have duplicate entries: that is, if idx1 != idx2,
  then indices[idx1] != indices[idx2]. This ensures that the output value does not depend on the iteration order.
  When `reduction` is set to some reduction function `f`, `output` is calculated as follows:

  ```
  output = np.copy(data)
  update_indices = indices.shape[:-1]
  for idx in np.ndindex(update_indices):
      output[indices[idx]] = f(output[indices[idx]], updates[idx])
  ```

  where the `f` is `+`, `*`, `max` or `min` as specified.

  This operator is the inverse of GatherND.

  (Opset 18 change): Adds max/min to the set of allowed reduction ops.

  Example 1:
  ```
  data    = [1, 2, 3, 4, 5, 6, 7, 8]
  indices = [[4], [3], [1], [7]]
  updates = [9, 10, 11, 12]
  output  = [1, 11, 3, 10, 9, 6, 7, 12]
  ```

  Example 2:
  ```
  data    = [[[1, 2, 3, 4], [5, 6, 7, 8], [8, 7, 6, 5], [4, 3, 2, 1]],
              [[1, 2, 3, 4], [5, 6, 7, 8], [8, 7, 6, 5], [4, 3, 2, 1]],
              [[8, 7, 6, 5], [4, 3, 2, 1], [1, 2, 3, 4], [5, 6, 7, 8]],
              [[8, 7, 6, 5], [4, 3, 2, 1], [1, 2, 3, 4], [5, 6, 7, 8]]]
  indices = [[0], [2]]
  updates = [[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],
              [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]]]
  output  = [[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],
              [[1, 2, 3, 4], [5, 6, 7, 8], [8, 7, 6, 5], [4, 3, 2, 1]],
              [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]],
              [[8, 7, 6, 5], [4, 3, 2, 1], [1, 2, 3, 4], [5, 6, 7, 8]]]
  ```
attributes:
  - name: reduction
    description: >-
      Type of reduction to apply: none (default), add, mul, max, min. 'none': no reduction
      applied. 'add':  reduction using the addition operation. 'mul':  reduction using
      the addition operation. 'max': reduction using the maximum operation.'min':
      reduction using the minimum operation.
    type: STRING
    required: false
    default_value: none
inputs:
  - name: data
    type_str: T
    description: Tensor of rank r >= 1.
    min_arity: 1
    tags:
      - differentiable
  - name: indices
    type_str: tensor(int64)
    description: Tensor of rank q >= 1.
    min_arity: 1
    tags:
      - non-differentiable
  - name: updates
    type_str: T
    description: Tensor of rank q + r - indices_shape[-1] - 1.
    min_arity: 1
    tags:
      - differentiable
outputs:
  - name: output
    type_str: T
    description: Tensor of rank r >= 1.
    min_arity: 1
    tags:
      - differentiable
type_constraints:
  - type_param_str: T
    description: Constrain input and output types to any tensor type.
    allowed_type_strs:
      - tensor(uint8)
      - tensor(uint16)
      - tensor(uint32)
      - tensor(uint64)
      - tensor(int8)
      - tensor(int16)
      - tensor(int32)
      - tensor(int64)
      - tensor(bfloat16)
      - tensor(float16)
      - tensor(float)
      - tensor(double)
      - tensor(string)
      - tensor(bool)
      - tensor(complex64)
      - tensor(complex128)
support_level: COMMON
deprecated: false
