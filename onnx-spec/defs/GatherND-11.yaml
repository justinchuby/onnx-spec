domain: ''
name: GatherND
since_version: 11
min_input: 2
max_input: 2
min_output: 1
max_output: 1
doc: "\nGiven `data` tensor of rank `r` >= 1, and `indices` tensor of rank `q` >=\
  \ 1, this operator gathers\nslices of `data` into an output tensor of rank `q +\
  \ r - indices_shape[-1] - 1`.\n\n`indices` is an q-dimensional integer tensor, best\
  \ thought of as a `(q-1)`-dimensional tensor of index-tuples into `data`,\nwhere\
  \ each element defines a slice of `data`\n\nSome salient points about the inputs'\
  \ rank and shape:\n\n1) r >= 1 and q >= 1 are to be honored. There is no dependency\
  \ condition to be met between ranks `r` and `q`\n\n2) The `indices_shape[-1]` should\
  \ have a value between 1 (inclusive) and rank `r` (inclusive)\n\n3) All values in\
  \ `indices` are expected to be within bounds [-s, s-1] along axis of size `s` (i.e.)\
  \ `-data_shape[i] <= indices[...,i] <= data_shape[i] - 1`.\n   It is an error if\
  \ any of the index values are out of bounds.\n\nThe output is computed as follows:\n\
  \nThe output tensor is obtained by mapping each index-tuple in the `indices` tensor\
  \ to the corresponding slice of the input `data`.\n\n1) If `indices_shape[-1] >\
  \ r` => error condition\n\n2) If `indices_shape[-1] == r`, since the rank of `indices`\
  \ is `q`, `indices` can be thought of as a `(q-1)`-dimensional tensor\n   containing\
  \ 1-D tensors of dimension `r`. Let us think of each such `r` ranked tensor as `indices_slice`.\n\
  \   Each *scalar value* corresponding to `data[indices_slice]` is filled into the\
  \ corresponding location of the `(q-1)`-dimensional tensor\n   to form the `output`\
  \ tensor (Example 1 below)\n\n3) If `indices_shape[-1] < r`, since the rank of `indices`\
  \ is `q`, `indices` can be thought of as a `(q-1)`-dimensional tensor\n   containing\
  \ 1-D tensors of dimension `< r`. Let us think of each such tensors as `indices_slice`.\n\
  \   Each *tensor slice* corresponding to `data[indices_slice , :]` is filled into\
  \ the corresponding location of the `(q-1)`-dimensional tensor\n   to form the `output`\
  \ tensor (Examples 2, 3, and 4 below)\n\nThis operator is the inverse of `ScatterND`.\n\
  \n`Example 1`\n\n  data    = [[0,1],[2,3]]   # data_shape = [2, 2]\n\n  indices\
  \ = [[0,0],[1,1]]   # indices_shape = [2, 2]\n\n  output  = [0,3]           # output_shape\
  \ = [2]\n\n`Example 2`\n\n  data    = [[0,1],[2,3]]  # data_shape = [2, 2]\n\n \
  \ indices = [[1],[0]]      # indices_shape = [2, 1]\n\n  output  = [[2,3],[0,1]]\
  \  # output_shape = [2, 2]\n\n`Example 3`\n\n  data    = [[[0,1],[2,3]],[[4,5],[6,7]]]\
  \ # data_shape = [2, 2, 2]\n\n  indices = [[0,1],[1,0]]                 # indices_shape\
  \ = [2, 2]\n\n  output  = [[2,3],[4,5]]                 # output_shape = [2, 2]\n\
  \n`Example 4`\n\n  data    = [[[0,1],[2,3]],[[4,5],[6,7]]] # data_shape = [2, 2,\
  \ 2]\n\n  indices = [[[0,1]],[[1,0]]]             # indices_shape = [2, 1, 2]\n\n\
  \  output  = [[[2,3]],[[4,5]]]             # output_shape = [2, 1, 2]\n\n"
attributes: []
inputs:
- name: data
  type_str: T
  description: Tensor of rank r >= 1.
  min_arity: 1
  tags: []
- name: indices
  type_str: tensor(int64)
  description: Tensor of rank q >= 1. All index values are expected to be within bounds
    [-s, s-1] along axis of size s. It is an error if any of the index values are
    out of bounds.
  min_arity: 1
  tags: []
outputs:
- name: output
  type_str: T
  description: Tensor of rank q + r - indices_shape[-1] - 1.
  min_arity: 1
  tags: []
type_constraints:
- type_param_str: T
  description: Constrain input and output types to any tensor type.
  allowed_type_strs:
  - tensor(uint8)
  - tensor(uint16)
  - tensor(uint32)
  - tensor(uint64)
  - tensor(int8)
  - tensor(int16)
  - tensor(int32)
  - tensor(int64)
  - tensor(float16)
  - tensor(float)
  - tensor(double)
  - tensor(string)
  - tensor(bool)
  - tensor(complex64)
  - tensor(complex128)
support_level: COMMON
deprecated: false
